# 实验目的

通过完成本项目，掌握物理层传输的基本原理；理解传输过程中的编解码、噪声、分辨率、波特率、调制与误码等概念；掌握奈奎斯特（Nyquist）定理与香农（Shannon）定理的含义，并能将这些理论用于系统设计、编码与解码的权衡。

# 时间要求

- 预计开发与实验实现时间：4 周
- 成果整理与报告时间：1 周
- 最终提交时间：第 5 周周日之前

# 需求说明（概述）

本课程项目由发送端（编码器）与接收端（解码器）两部分组成。总体流程：用户提供要传输的二进制文件 → 发送端将二进制编码为一系列图像并生成视频 → 在显示器上播放视频 → 用手机拍摄回放视频 → 将拍摄视频拷回电脑 → 接收端对视频解码为图像并还原二进制文件。

为了降低移动端开发门槛，允许采用桌面端工具（FFmpeg / OpenCV）生成与解析视频：

- 发送端（编码器）职责：读取输入二进制文件，将其映射为像素/帧序列（按约定的编码方案），输出一个约定时长的视频文件（不能超过用户指定的时长）。
- 接收端（解码器）职责：将手机拍摄视频解码为图像序列，按同样的解码规则还原比特流，输出二进制文件并给出每个位的有效性标记。

# 输入 / 输出 接口（规范）

### 编码器（Encoder）

- 命令行接口（示例）：

```
encode in.bin out.mp4 1000
```

参数说明：
- `argv[1]`：输入二进制文件（例如 `in.bin`），长度 ≤ 10MB（可按需求调整）。
- `argv[2]`：输出视频文件名（例如 `out.mp4`）。
- `argv[3]`：视频最大时长（毫秒，单位 ms）。程序不得生成超过该时长的视频。

编码器实现要点：
- 将输入比特流分帧并映射到图像（例如每帧若干像素代表若干比特或每帧显示条纹表示比特序列）。
- 使用 FFmpeg 或 OpenCV 将图像序列编码为视频文件（示例命令见下）。
- 编码过程不应在终端播放视频。

FFmpeg 生成视频示例（把命名为 frame_0001.png 的图像序列转为 MP4）：

```bash
ffmpeg -framerate 30 -i frame_%04d.png -c:v libx264 -pix_fmt yuv420p -t 1 out.mp4
```
（以上命令生成约 1 秒的视频，`-t` 以秒为单位；若用户要求以毫秒为约束，请换算或用 `-to`/`-ss` 精确控制时长。）

### 解码器（Decoder）

- 命令行接口（示例）：

```
decode recorded.mp4 out.bin vout.bin
```

参数说明：
- `argv[1]`：手机拍摄并拷回的输入视频文件（例如 `recorded.mp4`）。
- `argv[2]`：解码后输出的二进制文件（例如 `out.bin`）。
- `argv[3]`：每位有效性标记输出文件（例如 `vout.bin`），为二进制文件，其中每个位或每字节标记对应位是否正确（格式如下）。

解码器实现要点：
- 使用 FFmpeg 将视频解码为图像序列，或直接用 OpenCV 读取帧；示例命令见下。
- 根据编码规范从图像中恢复比特流；输出原始二进制文件（`out.bin`）以及用于标记每个位是否被正确恢复的有效性数组（`vout.bin`）。

FFmpeg 解码为图像示例：

```bash
ffmpeg -i recorded.mp4 frame_%04d.png
```

说明：`vout.bin` 的格式约定应在项目中明确（示例实现建议：每个输出字节表示对应 `out.bin` 中同一字节的每一位是否正确，或使用每位一个字节的方式；评测脚本需与实现方约定）。举例：

- 假设 `out.bin` 为十六进制字节序： `13 2F 9B C7`
- `vout.bin` 对应标记（按字节）可以是： `FF FC FF F0`（这里示例表示每位的有效性位掩码，1 表示该位正确、0 表示该位错误）。

> 注意：所有示例中的文件均为二进制文件（非文本）。

# 技术建议

- 开发语言：自选（推荐 C / C++ / Python）。
- 强烈建议熟悉 FFmpeg 命令行或 OpenCV（对帧操作、色彩空间、采样与插值十分有帮助）。
- 推荐先用图像序列实现编码/解码流程，再把图像序列与 FFmpeg 结合生成/解析视频。
- 注意帧率（fps）、像素分辨率、颜色空间（建议使用 YUV420 / RGB）、以及视频压缩对像素颜色精度的影响。
- 在设计编码方案时，要考虑环境光照、显示器刷新、手机摄像头自动曝光/自动白平衡等实际因素。
- 鼓励使用现成的多媒体库（如 libav/FFmpeg API、OpenCV 视频 I/O）而不是仅依赖外部可执行文件，以获得更精确的控制和更高的可移植性。

# 评分标准

评分以有效传输量与软件质量为主；不得通过生成比指定时长更长的视频来作弊。评分指标建议如下：

1. 有效传输量（bits）：在规定时长内，除去标记为错误和校验位之后的第一段正确接收位总数（从第一个位开始，直到遇到第一个未被标记但实际错误的位，不包含该错误位）。
2. 总传输量（bits）：在规定时长内传输（包含校验、错误标记与实际错误位）的总比特数（不含前导同步码）。
3. 有效传输率（bps）：有效传输量 / 视频播放时长（秒）。
4. 误码率（BER, %）：未标记错误但接收错误的比特数 ÷ 总传输量。
5. 丢失率（%）：被标记为错误（不可用）的比特数 ÷ 总传输量。

注：第 1 项为主要排序依据，其它指标作为参考说明项目性能。

## 附录一：参考学生作品

- 李泽政（2018 级）示例：
  - https://github.com/poor-circle/Visual-Net
  - https://gitee.com/whuangxm/project-1-eg-lzz

- 宋润涵等团队示例：
  - https://github.com/sh963852741/GroupTest
  - https://gitee.com/whuangxm/project-1-eg-srh

## 附录二：OpenCV 使用提示

- OpenCV 发布页： https://github.com/opencv/opencv/releases
- Windows 下快速启动（示例）：下载合适的预编译包（例如 opencv-4.x.x-vc14_vc15.exe），解压后在 Visual Studio 中配置：
  - 头文件目录： `C:\opencv\build\include`
  - 库文件目录： `C:\opencv\build\x64\vc15\lib`
  - 链接库：例如 `opencv_world455.lib`（根据版本调整）
